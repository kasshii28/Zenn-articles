---
title: "Utility Typesの使いかたをまとめてみた"
emoji: "✝️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["typescript", "tech"]
published: false
---
# Utility Typesとは?
`Utility Types`はTypescriptの既存の型を再利用・加工などが出来る便利な型です。
既に定義されている型と似たような型が欲しい時などに`Utility Types`を使うことで、コードの重複を減らすことが出来たりします。

# `Awaited<T>`
`Awaited<T>`は`await`や`.then()`を使った時に得られる値の型を扱う時に使えます。
例えば非同期関数の戻り値の型が欲しい時などです。
```ts
// 基本的な構文
type Sample = Awaited<Promise<string>>

// 非同期関数の戻り値から型が欲しい時
async function fetchData(): Promise<{ name: string }>{
    return { name: "sampleName" }
}

// 非同期関数の戻り値の型
type ResultFetchData = Awaited<ReturnType<typeof fetchData>>

```
# `Partial<T>`
`Partial<T>`は`<T>`の全てのプロパティをOptional(任意)にすることが出来ます。
主にデータの更新をする際などに使用されます。

```ts
interface Person {
    name: string;
    age: number;
}

// Personの情報を更新する関数
function updatePerson(person: Person, updates: Partial<Person>){
    return { ...person, ...updates };
}

// 1回目: 登録
const firstPerson = {
    name: "first",
    age: 1
}

// 2回目: 更新
const secondPerson = updatePerson(firstPerson, {
    name: "second",
    age: 2
})
```

# `Required<T>`
`Required<T>`は`<T>`の全てのプロパティをRequired(必須)にすることが出来ます。
これは`Partial<T>`とは反対の動きになります。
```ts
interface Person {
    name?: string;
    age?: number;
}

// Optionalの場合
const person: Person = {
    name: "only name"
}
// ☑ nameだけでもOK

// Reuquiredの場合 
const person: Required<Person> = {
    name: "only name"
}
// ❌️ nameだけだとError

const person: Required<Person> = {
    name: "name and age",
    age: 1
}
// ☑ 全てのプロパティが代入されているのでOK
```

# `Readonly<T>`
`Readonly<T>`は`<T>`の全てのプロパティを`readonly`(読み取り専用)にすることが出来ます。
これでプロパティの代入が禁止されるため、イミュータブルなオブジェクトとして扱えます。

```ts
interface Person {
    name: string;
    age: number
}

const person: Readonly<Person> = {
    name: "first",
    age: 1
}

person.name = "second"
// ❌️ 再代入しようとするとError

```
# `Record<K,T>`
`Record<K,T>`はキーの型が`<K>`で、その値の型が`<T>`のオブジェクト型を作ることが出来ます。
型のプロパティを別の型にマッピングする時に使用されます。

```ts
type PersonName = "first" | "second"

interface PersonInfo {
    age: number;
    from: string
}

// personごとの情報がある型が作れる
const people: Record<PersonName, PersonInfo> = {
    first: { age: 1, from : "JP" },
    second: { age: 2, from : "US" }
}

people.first // { age: 1, from: "JP" }
people.second.age // 2
```

# `Pick<T,K>`
`Pick<T,K>`は型`<T>`から、型に含まれるプロパティ`<K>`を抽出して型を作ることが出来ます。
既存の型から特定のプロパティだけを抽出して型を作りたい場合に使われます。

```ts
interface Person {
    id: number
    name: string;
    age: number;
    from: string;
    email: string;
}

// 公開情報だけを抽出
type PublicPerson = Pick<Person, "name" | "from">

// 非公開情報を持たないデータの型を作れる
const person: PublicPerson = {
    name: "public",
    from: "JP"
}
```

# `Omit<T,K>`
`Omit<T,K>`は型`<T>`から型に含まれるプロパティ`<K>`を除外して型を作ることが出来ます。
既存の型から特定のプロパティだけを除外して型を作りたい時に使われます。
`Pick<T,K>`と反対の動きになります。

```ts
interface Person {
    id: number
    name: string;
    age: number;
    from: string;
    email: string;
}

// 非公開情報だけを除外
type PublicPerson = Omit<Person, "id" | "age" | "email">

// 非公開情報を持たないデータの型を作れる
const person: PublicPerson = {
    name: "public",
    from: "JP"
}
```

# `Exclude<T,U>`
`Exclude<T,U>`は元のUnion型`<T>`から型`<U>`を除外して型を作ることができます。
```ts
type Color = "red" | "blue" | "green"

type Color1 = Exclude<Color, "green"> 
// red | blue

type Color2 = Exclude<Color, "red" | "blue">
// green

type PersonInfo = 
    | { age: 1, from : "JP" }
    | { age: 2, from : "US" }

type PersonInfo1 = Exclude<PersonInfo, { age: 1 }>
// { age: 2, from "US" }
// age:1を含んでいるものを除外

type ResultNever = Exclude<PersonInfo, { age: 1 } | { age: 2 }>
// 全て除外された場合はneverになる
```

# `Extract<T,U>`
`Extract<T,U>`は元のUnion型`<T>`から型`<U>`を抽出して型を作ることが出来ます。
`Exclude<T,U>`と反対の動きになります。

```ts
type Color = "red" | "blue" | "green"

type Color1 = Extract<Color, "green"> 
// green

type Color2 = Extract<Color, "red" | "yellow">
// red

type PersonInfo = 
    | { age: 1, from : "JP" }
    | { age: 2, from : "US" }

type PersonInfo1 = Extract<PersonInfo, { age: 1 }>
// { age: 1, from "JP" }
// age:1を含んでいるものを抽出
```

# `NonNullable<T>`
`NonNullable<T>`は`<T>`から`null`と`undefined`を除外した型を作ることが出来ます。

```ts
type Color0 = "red" | "blue" | "green" | null
type Color1 = "red" | "blue" | "green" | null | undefined

type Color0 = NonNullable<Color0>
// red | blue | green

type Color1 = NonNullable<Color1>
// red | blue | green
```

# `Parameters<T>`
`Paramters<T>`は`<T>`の引数の型をタプル型として抽出した型を作ることが出来ます。

```ts
const function func(a: number, b:number): number {
    return a+b
}

type F0 = Parameters<() => number>
// []

type F1 = Parameters<(num: number) => number>
// [num: number]

type F2 = Parameters<<T>(arg: T) => T>
// [arg: unknown]

type F3 = Parameters<typeof func>
// [a: number, b:number]

type F4
```